Got it. To achieve this, you'll want to modify the on trigger of the publish workflow. We'll remove the workflow_run trigger and replace it with release and a conditional workflow_dispatch for manual releases. The release trigger will activate when a new GitHub Release is published (which typically involves pushing a tag).

Here's the modified publish-to-pypi.yml workflow:

YAML

name: Publish Python Wheels to PyPI

on:
  release:
    types: [published] # This workflow runs when a new GitHub Release is published

  # Allows manual triggering from the GitHub Actions UI, typically for re-publishing
  workflow_dispatch:
    inputs:
      tag_name:
        description: 'Tag name of the release to publish (e.g., v1.0.0)'
        required: true

jobs:
  publish_to_pypi:
    name: Publish to PyPI
    runs-on: ubuntu-latest
    permissions:
      contents: read
      id-token: write # Required for trusted publishing to PyPI

    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      with:
        # If triggered by release, this will checkout the tag associated with the release.
        # If triggered by workflow_dispatch, we need to fetch the specific tag.
        ref: ${{ github.event_name == 'release' && github.event.release.tag_name || github.event.inputs.tag_name }}
        fetch-depth: 0

    # This step is crucial: it finds the 'Build Python Wheels' workflow run
    # associated with the tag that just triggered this release workflow.
    - name: Find and download workflow artifacts from the matching build
      uses: actions/github-script@v7
      id: download_artifacts
      with:
        script: |
          const tag = ${{ github.event_name == 'release' ? 'context.payload.release.tag_name' : 'github.event.inputs.tag_name' }};
          console.log(`Looking for workflow runs associated with tag: ${tag}`);

          // Find the workflow runs for 'Build Python Wheels' on the current repository
          // that are associated with the specific tag.
          // Note: GitHub Actions does not directly link a release to a specific workflow_run ID.
          // We look for successful 'Build Python Wheels' runs on the same commit/ref as the tag.
          const runs = await github.rest.actions.listWorkflowRunsForRepo({
            owner: context.repo.owner,
            repo: context.repo.repo,
            workflow_id: 'build-python-wheels.yml', // Replace with the actual filename if different
            branch: tag, // Search runs on the specific tag
            status: 'success', // Only consider successful builds
            per_page: 10 // Get a few recent runs
          });

          let foundRun = null;
          if (runs.data.workflow_runs.length > 0) {
              // Iterate through runs to find one that matches the commit SHA of the tag
              // For a release, the commit SHA of the tag should match the commit SHA of the workflow run.
              // For workflow_dispatch, we are checking out the tag directly, so the commit SHA will match.
              const currentRefSha = context.sha; // This is the SHA of the tag
              console.log(`Current ref SHA for tag ${tag}: ${currentRefSha}`);

              for (const run of runs.data.workflow_runs) {
                  console.log(`Checking build run ${run.id}, head_sha: ${run.head_sha}, event: ${run.event}, branch: ${run.head_branch}`);
                  if (run.head_sha === currentRefSha && run.conclusion === 'success') {
                      foundRun = run;
                      break;
                  }
              }
          }

          if (!foundRun) {
            console.log(`No successful 'Build Python Wheels' workflow run found for tag: ${tag} (commit SHA: ${context.sha}).`);
            core.setFailed('No successful build artifacts found for this release tag.');
            return;
          }

          console.log(`Found matching build run: ${foundRun.id}`);

          // Now, download artifacts from the found run ID
          const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
            owner: context.repo.owner,
            repo: context.repo.repo,
            run_id: foundRun.id,
          });

          const fs = require('fs');
          const path = require('path');
          const admZip = require('adm-zip');

          // Create the base directory for downloaded wheels
          const baseDownloadPath = path.join(process.env.GITHUB_WORKSPACE, 'downloaded-wheels');
          if (!fs.existsSync(baseDownloadPath)){
              fs.mkdirSync(baseDownloadPath, { recursive: true });
          }

          for (const artifact of artifacts.data.artifacts) {
            console.log(`Downloading artifact: ${artifact.name} (ID: ${artifact.id})`);
            const download = await github.rest.actions.downloadArtifact({
              owner: context.repo.owner,
              repo: context.repo.repo,
              artifact_id: artifact.id,
              archive_format: 'zip',
            });
            const zip = new admZip(Buffer.from(download.data));
            const targetPath = path.join(baseDownloadPath, artifact.name);
            zip.extractAllTo(targetPath, true);
            console.log(`Extracted artifact ${artifact.name} to ${targetPath}`);
          }

    - name: List downloaded wheels for verification
      run: |
        ls -R downloaded-wheels/

    - name: Publish wheels to PyPI
      uses: pypa/gh-action-pypi-publish@release/v1
      with:
        packages_dir: downloaded-wheels/ # This path holds the extracted wheels from each artifact
